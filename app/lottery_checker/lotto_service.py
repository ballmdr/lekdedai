#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Lotto Service - р╕Ър╕гр╕┤р╕Бр╕▓р╕гр╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕лр╕зр╕вр╕Ир╕▓р╕Б GLO API р╣Бр╕ер╕░р╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е
"""

import json
import requests
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
from django.utils import timezone

from .models import LottoResult

# Configure logging
logger = logging.getLogger(__name__)

class LottoService:
    """р╕Ър╕гр╕┤р╕Бр╕▓р╕гр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕лр╕зр╕в"""
    
    def __init__(self):
        self.api_url = "https://www.glo.or.th/api/checking/getLotteryResult"
        self.timeout = 10
    
    def fetch_from_api(self, date, month, year) -> Optional[Dict[str, Any]]:
        """р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б GLO API"""
        # р╣Бр╕Ыр╕ер╕Зр╣Ар╕Ыр╣Зр╕Щ integer р╕Цр╣Йр╕▓р╣Ар╕Ыр╣Зр╕Щ string
        try:
            date = int(date)
            month = int(month)
            year = int(year)
        except (ValueError, TypeError):
            logger.error(f"тЭМ р╕Др╣Ир╕▓ date, month, year р╕Хр╣Йр╕нр╕Зр╣Ар╕Ыр╣Зр╕Щр╕Хр╕▒р╕зр╣Ар╕ер╕В: date={date}, month={month}, year={year}")
            return None
            
        payload = {
            "date": date,
            "month": month,
            "year": year
        }
        
        try:
            logger.info(f"ЁЯМР р╕Бр╕│р╕ер╕▒р╕Зр╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б GLO API р╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Чр╕╡р╣И {date}/{month}/{year}")
            
            response = requests.post(
                self.api_url,
                json=payload,
                headers={'Content-Type': 'application/json'},
                timeout=self.timeout
            )
            
            if response.status_code == 200:
                data = response.json()
                logger.info("тЬЕ р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б API р╕кр╕│р╣Ар╕гр╣Зр╕И")
                return data
            else:
                logger.error(f"тЭМ API р╕кр╣Ир╕Зр╕Др╕╖р╕Щ status code: {response.status_code}")
                return None
                
        except requests.exceptions.RequestException as e:
            logger.error(f"тЭМ р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╣Ар╕гр╕╡р╕вр╕Б API: {e}")
            return None
        except json.JSONDecodeError as e:
            logger.error(f"тЭМ р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╣Бр╕Ыр╕ер╕З JSON р╣Др╕Фр╣Й: {e}")
            return None
    
    def get_or_fetch_result(self, date, month, year) -> Dict[str, Any]:
        """р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕лр╕зр╕вр╕Ир╕▓р╕Бр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е р╕лр╕гр╕╖р╕нр╕Фр╕╢р╕Зр╕Ир╕▓р╕Б API р╕Цр╣Йр╕▓р╕вр╕▒р╕Зр╣Др╕бр╣Ир╕бр╕╡"""
        try:
            # р╣Бр╕Ыр╕ер╕Зр╣Ар╕Ыр╣Зр╕Щ integer р╕Цр╣Йр╕▓р╣Ар╕Ыр╣Зр╕Щ string
            try:
                date = int(date)
                month = int(month)
                year = int(year)
            except (ValueError, TypeError):
                return {
                    "success": False,
                    "error": f"р╕Др╣Ир╕▓ date, month, year р╕Хр╣Йр╕нр╕Зр╣Ар╕Ыр╣Зр╕Щр╕Хр╕▒р╕зр╣Ар╕ер╕В: date={date}, month={month}, year={year}"
                }
            
            # р╕кр╕гр╣Йр╕▓р╕Зр╕зр╕▒р╕Щр╕Чр╕╡р╣И
            draw_date = datetime(year, month, date).date()
            
            # р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╕бр╕╡р╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕Щр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Бр╕ер╣Йр╕зр╕лр╕гр╕╖р╕нр╣Др╕бр╣И
            existing_result = LottoResult.objects.filter(draw_date=draw_date).first()
            
            if existing_result:
                logger.info(f"ЁЯУЛ р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Бр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Чр╕╡р╣И {draw_date.strftime('%d/%m/%Y')}")
                return {
                    "success": True,
                    "source": "database",
                    "data": existing_result.result_data,
                    "message": "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Бр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е",
                    "draw_date": existing_result.draw_date,
                    "updated_at": existing_result.updated_at
                }
            
            # р╕Цр╣Йр╕▓р╣Др╕бр╣Ир╕бр╕╡р╣Гр╕Щр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е р╣Гр╕лр╣Йр╕Фр╕╢р╕Зр╕Ир╕▓р╕Б API
            logger.info(f"ЁЯФН р╣Др╕бр╣Ир╕Юр╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕Щр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е р╕Фр╕╢р╕Зр╕Ир╕▓р╕Б API р╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Чр╕╡р╣И {draw_date.strftime('%d/%m/%Y')}")
            api_result = self.fetch_from_api(date, month, year)
            
            if not api_result:
                return {
                    "success": False,
                    "error": "р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б API р╣Др╕Фр╣Й"
                }
            
            # р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕ер╕Зр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е
            db_saved = self.save_to_database(api_result, draw_date)
            
            return {
                "success": True,
                "source": "api",
                "data": api_result,
                "message": "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б API р╣Бр╕ер╕░р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕ер╕Зр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Бр╕ер╣Йр╕з",
                "database_saved": db_saved,
                "draw_date": draw_date,
                "updated_at": timezone.now()
            }
            
        except Exception as e:
            logger.error(f"тЭМ р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щ get_or_fetch_result: {e}")
            return {
                "success": False,
                "error": f"р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Ф: {str(e)}"
            }
    
    def save_to_database(self, lotto_data: Dict[str, Any], draw_date: datetime.date) -> bool:
        """р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕лр╕зр╕вр╕ер╕Зр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е"""
        try:
            # р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╕бр╕╡р╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕Щр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Бр╕ер╣Йр╕зр╕лр╕гр╕╖р╕нр╣Др╕бр╣И
            existing_result = LottoResult.objects.filter(draw_date=draw_date).first()
            
            if existing_result:
                logger.info(f"ЁЯУЭ р╕нр╕▒р╕Ыр╣Ар╕Фр╕Хр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕лр╕зр╕вр╕Чр╕╡р╣Ир╕бр╕╡р╕нр╕вр╕╣р╣Ир╣Бр╕ер╣Йр╕зр╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Чр╕╡р╣И {draw_date.strftime('%d/%m/%Y')}")
                # р╕нр╕▒р╕Ыр╣Ар╕Фр╕Хр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Чр╕╡р╣Ир╕бр╕╡р╕нр╕вр╕╣р╣И
                existing_result.result_data = lotto_data
                existing_result.updated_at = timezone.now()
                existing_result.save()
            else:
                logger.info(f"ЁЯТ╛ р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕лр╕зр╕вр╣Гр╕лр╕бр╣Ир╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Чр╕╡р╣И {draw_date.strftime('%d/%m/%Y')}")
                # р╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕лр╕бр╣И
                LottoResult.objects.create(
                    draw_date=draw_date,
                    result_data=lotto_data,
                    source="GLO API"
                )
            
            return True
            
        except Exception as e:
            logger.error(f"тЭМ р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕ер╕Зр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е: {e}")
            return False
    
    def get_latest_results(self, days_back: int = 7) -> Dict[str, Any]:
        """р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕лр╕зр╕вр╕ер╣Ир╕▓р╕кр╕╕р╕Фр╕лр╕ер╕▓р╕вр╕зр╕▒р╕Щ"""
        results = []
        today = timezone.now().date()
        
        for i in range(days_back):
            target_date = today - timedelta(days=i)
            
            result = self.get_or_fetch_result(
                date=str(target_date.day),
                month=str(target_date.month),
                year=str(target_date.year)
            )
            
            if result["success"]:
                results.append({
                    "date": target_date.strftime('%d/%m/%Y'),
                    "draw_date": target_date,
                    "data": result["data"],
                    "source": result["source"],
                    "updated_at": result.get("updated_at")
                })
        
        return {
            "success": True,
            "total_results": len(results),
            "results": results
        }
    
    def clear_all_data(self) -> bool:
        """р╕ер╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Фр╣Гр╕Щр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е"""
        try:
            count = LottoResult.objects.count()
            LottoResult.objects.all().delete()
            logger.info(f"ЁЯЧСя╕П р╕ер╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф {count} р╕гр╕▓р╕вр╕Бр╕▓р╕гр╕кр╕│р╣Ар╕гр╣Зр╕И")
            return True
        except Exception as e:
            logger.error(f"тЭМ р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕ер╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е: {e}")
            return False
    
    def get_statistics(self) -> Dict[str, Any]:
        """р╕Фр╕╢р╕Зр╕кр╕Цр╕┤р╕Хр╕┤р╕Вр╣Йр╕нр╕бр╕╣р╕е"""
        try:
            total_records = LottoResult.objects.count()
            today_records = LottoResult.objects.filter(
                draw_date=timezone.now().date()
            ).count()
            recent_records = LottoResult.objects.filter(
                draw_date__gte=timezone.now().date() - timedelta(days=7)
            ).count()
            
            return {
                "success": True,
                "statistics": {
                    "total_records": total_records,
                    "today_records": today_records,
                    "recent_records": recent_records,
                    "last_updated": timezone.now()
                }
            }
        except Exception as e:
            logger.error(f"тЭМ р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Фр╕╢р╕Зр╕кр╕Цр╕┤р╕Хр╕┤: {e}")
            return {
                "success": False,
                "error": str(e)
            }

    def refresh_data_from_api(self, date, month, year) -> Dict[str, Any]:
        """р╕нр╕▒р╕Ыр╣Ар╕Фр╕Хр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б API р╕Бр╕нр╕Зр╕кр╕ер╕▓р╕Бр╣Гр╕лр╕бр╣И (р╕Ър╕▒р╕Зр╕Др╕▒р╕Ър╕Фр╕╢р╕Зр╣Гр╕лр╕бр╣И)"""
        try:
            # р╣Бр╕Ыр╕ер╕Зр╣Ар╕Ыр╣Зр╕Щ integer р╕Цр╣Йр╕▓р╣Ар╕Ыр╣Зр╕Щ string
            try:
                date = int(date)
                month = int(month)
                year = int(year)
            except (ValueError, TypeError):
                return {
                    "success": False,
                    "error": f"р╕Др╣Ир╕▓ date, month, year р╕Хр╣Йр╕нр╕Зр╣Ар╕Ыр╣Зр╕Щр╕Хр╕▒р╕зр╣Ар╕ер╕В: date={date}, month={month}, year={year}"
                }
            
            # р╕кр╕гр╣Йр╕▓р╕Зр╕зр╕▒р╕Щр╕Чр╕╡р╣И
            draw_date = datetime(year, month, date).date()
            
            logger.info(f"ЁЯФД р╕Ър╕▒р╕Зр╕Др╕▒р╕Ър╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕лр╕бр╣Ир╕Ир╕▓р╕Б GLO API р╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Чр╕╡р╣И {draw_date.strftime('%d/%m/%Y')}")
            
            # р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕лр╕бр╣Ир╕Ир╕▓р╕Б API
            api_result = self.fetch_from_api(date, month, year)
            
            if not api_result:
                return {
                    "success": False,
                    "error": "р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б API р╣Др╕Фр╣Й"
                }
            
            # р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕ер╕Зр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е (р╕нр╕▒р╕Ыр╣Ар╕Фр╕Хр╕лр╕гр╕╖р╕нр╕кр╕гр╣Йр╕▓р╕Зр╣Гр╕лр╕бр╣И)
            db_saved = self.save_to_database(api_result, draw_date)
            
            if db_saved:
                logger.info(f"тЬЕ р╕нр╕▒р╕Ыр╣Ар╕Фр╕Хр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б API р╕кр╕│р╣Ар╕гр╣Зр╕Ир╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Чр╕╡р╣И {draw_date.strftime('%d/%m/%Y')}")
                return {
                    "success": True,
                    "source": "api_refresh",
                    "data": api_result,
                    "message": "р╕нр╕▒р╕Ыр╣Ар╕Фр╕Хр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Ир╕▓р╕Б API р╕Бр╕нр╕Зр╕кр╕ер╕▓р╕Бр╣Гр╕лр╕бр╣Ир╣Бр╕ер╣Йр╕з",
                    "database_saved": True,
                    "draw_date": draw_date,
                    "updated_at": timezone.now()
                }
            else:
                logger.error(f"тЭМ р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕ер╕Зр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Др╕Фр╣Йр╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Чр╕╡р╣И {draw_date.strftime('%d/%m/%Y')}")
                return {
                    "success": False,
                    "error": "р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕ер╕Зр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Др╕Фр╣Й"
                }
                
        except Exception as e:
            logger.error(f"тЭМ р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щ refresh_data_from_api: {e}")
            return {
                "success": False,
                "error": f"р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Ф: {str(e)}"
            }

    def validate_lotto_data(self, lotto_data: Dict[str, Any]) -> Dict[str, Any]:
        """р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Др╕зр╕▓р╕бр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕Зр╕Вр╕нр╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕лр╕зр╕в"""
        try:
            if not isinstance(lotto_data, dict):
                return {
                    "is_valid": False,
                    "error": "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Др╕бр╣Ир╣Гр╕Кр╣Ир╕гр╕╣р╕Ыр╣Бр╕Ър╕Ър╕Чр╕╡р╣Ир╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З"
                }
            
            # р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╕бр╕╡р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕гр╕▓р╕Зр╕зр╕▒р╕ер╕Чр╕╡р╣Ир╕Ир╕│р╣Ар╕Ыр╣Зр╕Щр╕лр╕гр╕╖р╕нр╣Др╕бр╣И
            required_fields = ['first', 'second', 'third', 'fourth', 'fifth']
            missing_fields = []
            
            for field in required_fields:
                if field not in lotto_data:
                    missing_fields.append(field)
                elif not isinstance(lotto_data[field], dict) or 'number' not in lotto_data[field]:
                    missing_fields.append(field)
            
            if missing_fields:
                return {
                    "is_valid": False,
                    "error": f"р╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Др╕бр╣Ир╕Др╕гр╕Ър╕Цр╣Йр╕зр╕Щ: р╕Вр╕▓р╕Ф {', '.join(missing_fields)}",
                    "missing_fields": missing_fields
                }
            
            # р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Др╕бр╣Ир╕зр╣Ир╕▓р╕Зр╣Ар╕Ыр╕ер╣Ир╕▓
            for field in required_fields:
                if not lotto_data[field]['number'] or len(lotto_data[field]['number']) == 0:
                    return {
                        "is_valid": False,
                        "error": f"р╕Вр╣Йр╕нр╕бр╕╣р╕е {field} р╕зр╣Ир╕▓р╕Зр╣Ар╕Ыр╕ер╣Ир╕▓",
                        "empty_field": field
                    }
            
            return {
                "is_valid": True,
                "message": "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З"
            }
            
        except Exception as e:
            logger.error(f"тЭМ р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕е: {e}")
            return {
                "is_valid": False,
                "error": f"р╣Ар╕Бр╕┤р╕Фр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╣Гр╕Щр╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ: {str(e)}"
            }
